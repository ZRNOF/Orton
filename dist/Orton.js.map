{"mappings":"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","sources":["src/Orton.ts","src/DataType.ts","src/errorMask.ts","src/Shader.ts","src/Buffer.ts","src/Vertex.ts","src/BindGroup.ts","src/Pipeline.ts","src/Pass.ts"],"sourcesContent":["import { Data } from \"./DataType.js\"\r\nimport { errorMask } from \"./errorMask.js\"\r\nimport { Shader } from \"./Shader.js\"\r\nimport { Buffer } from \"./Buffer.js\"\r\nimport { createVertexAttribute, createVertexBufferLayout } from \"./Vertex.js\"\r\nimport { Binding, Group, BindGroup } from \"./BindGroup.js\"\r\nimport {\r\n\tPipeline,\r\n\tPipelineLayout,\r\n\tComputePipeline,\r\n\tRenderPipeline,\r\n} from \"./Pipeline.js\"\r\nimport {\r\n\tPass,\r\n\tbeginComputePass,\r\n\tbeginRenderPass,\r\n\tcreateRenderPassDescriptor,\r\n} from \"./Pass.js\"\r\n\r\nconst init = async (\r\n\tcanvas: HTMLCanvasElement,\r\n\toptions?: GPUDeviceDescriptor | undefined\r\n) => {\r\n\tconst gpu: GPU = (navigator as any).gpu\r\n\r\n\tif (!gpu) {\r\n\t\tconst msg = `WebGPU is not supported in this browser`\r\n\t\tconsole.error(msg)\r\n\t\terrorMask(\"Error\", msg)\r\n\t\treturn\r\n\t}\r\n\r\n\tconst adapter = await gpu.requestAdapter()\r\n\tif (!adapter) {\r\n\t\tconst msg = `couldn't request WebGPU adapter`\r\n\t\tconsole.error(msg)\r\n\t\terrorMask(\"Error\", msg)\r\n\t\treturn\r\n\t}\r\n\r\n\tconst device = await adapter?.requestDevice(options)\r\n\tdevice.lost.then(() => {\r\n\t\tconst msg = `WebGPU device was lost...`\r\n\t\tconsole.error(msg)\r\n\t\treturn\r\n\t})\r\n\r\n\tconst context = canvas.getContext(\"webgpu\")\r\n\tconst preferredFormat = gpu.getPreferredCanvasFormat()\r\n\tconst queue = device.queue\r\n\tconst getCurrentTexture = () => context?.getCurrentTexture()\r\n\tconst createView = () => context?.getCurrentTexture().createView()\r\n\tconst CommandEncoder = (device: GPUDevice) => device.createCommandEncoder()\r\n\r\n\treturn {\r\n\t\tgpu,\r\n\t\tadapter,\r\n\t\tdevice,\r\n\t\tcontext,\r\n\t\tpreferredFormat,\r\n\t\tqueue,\r\n\t\tgetCurrentTexture,\r\n\t\tcreateView,\r\n\t\tCommandEncoder,\r\n\t\t// Shader\r\n\t\tShader,\r\n\t\t// Buffer\r\n\t\tBuffer,\r\n\t\t// Vertex\r\n\t\tcreateVertexAttribute,\r\n\t\tcreateVertexBufferLayout,\r\n\t\t// BindGroup\r\n\t\tBinding,\r\n\t\tGroup,\r\n\t\tBindGroup,\r\n\t\t// Pipeline\r\n\t\tPipelineLayout,\r\n\t\tComputePipeline,\r\n\t\tRenderPipeline,\r\n\t\tPipeline,\r\n\t\t// Pass\r\n\t\tbeginComputePass,\r\n\t\tbeginRenderPass,\r\n\t\tcreateRenderPassDescriptor,\r\n\t\tPass,\r\n\t}\r\n}\r\n\r\nconst Orton = { init }\r\n\r\nexport {\r\n\tData,\r\n\tOrton,\r\n\tinit,\r\n\t// Shader\r\n\tShader,\r\n\t// Buffer\r\n\tBuffer,\r\n\t// Vertex\r\n\tcreateVertexAttribute,\r\n\tcreateVertexBufferLayout,\r\n\t// BindGroup\r\n\tBinding,\r\n\tGroup,\r\n\tBindGroup,\r\n\t// Pipeline\r\n\tPipelineLayout,\r\n\tComputePipeline,\r\n\tRenderPipeline,\r\n\tPipeline,\r\n\t// Pass\r\n\tbeginComputePass,\r\n\tbeginRenderPass,\r\n\tcreateRenderPassDescriptor,\r\n\tPass,\r\n}\r\n","const typeMap = {\r\n\ti8: Int8Array,\r\n\ti16: Int16Array,\r\n\ti32: Int32Array,\r\n\tu8: Uint8Array,\r\n\tu16: Uint16Array,\r\n\tu32: Uint32Array,\r\n\tf32: Float32Array,\r\n} as const\r\ntype TypeMapKeys = keyof typeof typeMap\r\n\r\nconst flat = (array: number[]) => {\r\n\treturn array.flat(Infinity)\r\n}\r\n\r\nexport const Data = (data: number | number[], type: TypeMapKeys = \"f32\") => {\r\n\tif (Array.isArray(data)) return new typeMap[type](flat(data))\r\n\tif (typeof data === \"number\") return new typeMap[type](data)\r\n\tthrow new Error(\"Unsupported data type\")\r\n}\r\n","export const errorMask = (title: string, detail: string) => {\r\n\tconst errorOverlay = document.createElement(\"div\")\r\n\terrorOverlay.style.cssText = `\r\n\t\t\tposition: fixed;\r\n\t\t\ttop: 0;\r\n\t\t\tleft: 0;\r\n\t\t\twidth: 100%;\r\n\t\t\theight: 100%;\r\n\t\t\tbackground: rgba(0, 0, 0, 0.9);\r\n\t\t\tdisplay: none;\r\n\t\t\tdisplay: flex;\r\n\t\t\tjustify-content: center;\r\n\t\t\talign-items: center;\r\n\t\t\tz-index: 999;\r\n\t`\r\n\r\n\tconst errorText = document.createElement(\"div\")\r\n\terrorText.style.cssText = `\r\n\t\t\tcolor: red;\r\n\t\t\tfont-size: 24px;\r\n\t\t\ttext-align: center;\r\n\t\t\tfont-family: 'Consolas', monospace;\r\n\t`\r\n\terrorText.innerHTML = `<h2>${title}</h2><p>${detail}</p>`\r\n\r\n\terrorOverlay.appendChild(errorText)\r\n\tdocument.body.appendChild(errorOverlay)\r\n\r\n\tfunction showErrorOverlay() {\r\n\t\terrorOverlay.style.display = \"flex\" // Show the error overlay\r\n\t}\r\n\r\n\tfunction hideErrorOverlay() {\r\n\t\terrorOverlay.style.display = \"none\" // Hide the error overlay\r\n\t}\r\n\r\n\terrorOverlay.addEventListener(\"click\", hideErrorOverlay)\r\n\r\n\treturn {\r\n\t\tshow: showErrorOverlay,\r\n\t\thide: hideErrorOverlay,\r\n\t}\r\n}\r\n","export interface VertexShaderProps {\r\n\tcode: string\r\n\tbuffers: Iterable<GPUVertexBufferLayout>\r\n\tentryPoint?: string\r\n\tlabel?: string | undefined\r\n}\r\n\r\nexport interface FragmentShaderProps {\r\n\tcode: string\r\n\ttargets: Iterable<GPUColorTargetState>\r\n\tentryPoint?: string\r\n\tlabel?: string | undefined\r\n}\r\n\r\nexport interface ComputeShaderProps {\r\n\tcode: string\r\n\tentryPoint?: string\r\n\tlabel?: string | undefined\r\n}\r\n\r\nexport const VertexShader = (\r\n\tdevice: GPUDevice,\r\n\tprops: VertexShaderProps\r\n): GPUVertexState => {\r\n\treturn {\r\n\t\tmodule: device.createShaderModule({\r\n\t\t\tlabel: props.label,\r\n\t\t\tcode: props.code,\r\n\t\t}),\r\n\t\tentryPoint: props.entryPoint || \"main\",\r\n\t\tbuffers: props.buffers,\r\n\t}\r\n}\r\n\r\nexport const FragmentShader = (\r\n\tdevice: GPUDevice,\r\n\tprops: FragmentShaderProps\r\n): GPUFragmentState => {\r\n\treturn {\r\n\t\tmodule: device.createShaderModule({\r\n\t\t\tlabel: props.label,\r\n\t\t\tcode: props.code,\r\n\t\t}),\r\n\t\tentryPoint: props.entryPoint || \"main\",\r\n\t\ttargets: props.targets,\r\n\t}\r\n}\r\n\r\nexport const ComputeShader = (\r\n\tdevice: GPUDevice,\r\n\tprops: ComputeShaderProps | string\r\n): GPUProgrammableStage => {\r\n\tif (typeof props === \"string\") {\r\n\t\treturn {\r\n\t\t\tmodule: device.createShaderModule({\r\n\t\t\t\tcode: props,\r\n\t\t\t}),\r\n\t\t\tentryPoint: \"main\",\r\n\t\t}\r\n\t}\r\n\treturn {\r\n\t\tmodule: device.createShaderModule({\r\n\t\t\tlabel: props.label,\r\n\t\t\tcode: props.code,\r\n\t\t}),\r\n\t\tentryPoint: props.entryPoint || \"main\",\r\n\t}\r\n}\r\n\r\nexport const Shader = {\r\n\tVertex: VertexShader,\r\n\tFragment: FragmentShader,\r\n\tCompute: ComputeShader,\r\n}\r\n","export type BufferUsage =\r\n\t| \"MAP_READ\"\r\n\t| \"MAP_WRITE\"\r\n\t| \"COPY_SRC\"\r\n\t| \"COPY_DST\"\r\n\t| \"INDEX\"\r\n\t| \"VERTEX\"\r\n\t| \"UNIFORM\"\r\n\t| \"STORAGE\"\r\n\t| \"INDIRECT\"\r\n\t| \"QUERY_RESOLVE\"\r\n\r\nexport interface BufferDescriptor {\r\n\tlabel?: string\r\n\tusage: BufferUsage[]\r\n\tsize: number\r\n\tmappedAtCreation?: boolean\r\n}\r\n\r\nexport const Buffer = (device: GPUDevice, descriptor: BufferDescriptor) => {\r\n\treturn device.createBuffer({\r\n\t\tlabel: descriptor.label,\r\n\t\tsize: descriptor.size,\r\n\t\tusage: descriptor.usage.reduce((acc, usage) => {\r\n\t\t\treturn acc | GPUBufferUsage[usage]\r\n\t\t}, 0),\r\n\t})\r\n}\r\n","export const createVertexAttribute = ({\r\n\tformat,\r\n\toffset,\r\n\tshaderLocation,\r\n}: GPUVertexAttribute): GPUVertexAttribute => {\r\n\treturn {\r\n\t\tformat,\r\n\t\toffset,\r\n\t\tshaderLocation,\r\n\t}\r\n}\r\n\r\nexport const createVertexBufferLayout = ({\r\n\tarrayStride,\r\n\tstepMode = \"vertex\",\r\n\tattributes,\r\n}: GPUVertexBufferLayout): GPUVertexBufferLayout => {\r\n\treturn {\r\n\t\tarrayStride,\r\n\t\tstepMode,\r\n\t\tattributes,\r\n\t}\r\n}\r\n","type ShaderStage = \"VERTEX\" | \"FRAGMENT\" | \"COMPUTE\"\r\n\r\nexport interface BindingProps {\r\n\ttype?: GPUBufferBindingType | undefined\r\n\tvisibility: ShaderStage[]\r\n\tbuffer: GPUBuffer\r\n\texternalTexture?: GPUExternalTextureBindingLayout | undefined\r\n\tsampler?: GPUSamplerBindingLayout | undefined\r\n\tstorageTexture?: GPUStorageTextureBindingLayout | undefined\r\n\ttexture?: GPUTextureBindingLayout | undefined\r\n}\r\n\r\nexport interface Binding extends BindingProps {\r\n\tbindGroupLayoutEntry: (binding: number) => GPUBindGroupLayoutEntry\r\n\tbindGroupEntry: (binding: number) => GPUBindGroupEntry\r\n}\r\n\r\nfunction isBinding(object: any): object is Binding {\r\n\treturn \"bindGroupLayoutEntry\" in object\r\n}\r\n\r\nexport const Binding = (props: BindingProps): Binding => {\r\n\tconst bindGroupLayoutEntry = (binding: number): GPUBindGroupLayoutEntry => {\r\n\t\treturn {\r\n\t\t\tbinding,\r\n\t\t\tvisibility: props.visibility.reduce((acc, stage) => {\r\n\t\t\t\treturn acc | GPUShaderStage[stage]\r\n\t\t\t}, 0),\r\n\t\t\tbuffer: { type: props.type },\r\n\t\t\texternalTexture: props.externalTexture,\r\n\t\t\tsampler: props.sampler,\r\n\t\t\tstorageTexture: props.storageTexture,\r\n\t\t\ttexture: props.texture,\r\n\t\t}\r\n\t}\r\n\tconst bindGroupEntry = (binding: number): GPUBindGroupEntry => {\r\n\t\treturn {\r\n\t\t\tbinding,\r\n\t\t\tresource: {\r\n\t\t\t\tbuffer: props.buffer,\r\n\t\t\t},\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\t...props,\r\n\t\tbindGroupLayoutEntry,\r\n\t\tbindGroupEntry,\r\n\t}\r\n}\r\n\r\nexport interface Group {\r\n\tgetLayoutEntries: () => GPUBindGroupLayoutEntry[]\r\n\tgetEntries: () => GPUBindGroupEntry[]\r\n}\r\n\r\nfunction isGroup(object: any): object is Group {\r\n\treturn \"getLayoutEntries\" in object\r\n}\r\n\r\nexport const Group = (Bindings: Binding[]): Group => {\r\n\tconst getLayoutEntries = () =>\r\n\t\tBindings.map((Binding, binding) => Binding.bindGroupLayoutEntry(binding))\r\n\tconst getEntries = () =>\r\n\t\tBindings.map((Binding, binding) => Binding.bindGroupEntry(binding))\r\n\treturn {\r\n\t\tgetLayoutEntries,\r\n\t\tgetEntries,\r\n\t}\r\n}\r\n\r\nexport interface BindGroupDescriptor {\r\n\tlabel?: string\r\n\tgroup: Group\r\n}\r\n\r\nfunction isBindGroupDescriptor(object: any): object is BindGroupDescriptor {\r\n\treturn \"group\" in object\r\n}\r\n\r\nexport const BindGroup = (\r\n\tdevice: GPUDevice,\r\n\tdescriptor: BindGroupDescriptor | Group | Binding[]\r\n) => {\r\n\tif (Array.isArray(descriptor)) {\r\n\t\tif (isBinding(descriptor[0])) {\r\n\t\t\tconst group = Group(descriptor)\r\n\t\t\tconst layout = device.createBindGroupLayout({\r\n\t\t\t\tentries: group.getLayoutEntries(),\r\n\t\t\t})\r\n\t\t\treturn {\r\n\t\t\t\tbindGroup: device.createBindGroup({\r\n\t\t\t\t\tlayout,\r\n\t\t\t\t\tentries: group.getEntries(),\r\n\t\t\t\t}),\r\n\t\t\t\tlayout,\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (isGroup(descriptor)) {\r\n\t\tconst layout = device.createBindGroupLayout({\r\n\t\t\tentries: descriptor.getLayoutEntries(),\r\n\t\t})\r\n\t\treturn {\r\n\t\t\tbindGroup: device.createBindGroup({\r\n\t\t\t\tlayout,\r\n\t\t\t\tentries: descriptor.getEntries(),\r\n\t\t\t}),\r\n\t\t\tlayout,\r\n\t\t}\r\n\t}\r\n\tif (isBindGroupDescriptor(descriptor)) {\r\n\t\tconst layout = device.createBindGroupLayout({\r\n\t\t\tentries: descriptor.group.getLayoutEntries(),\r\n\t\t})\r\n\t\treturn {\r\n\t\t\tbindGroup: device.createBindGroup({\r\n\t\t\t\tlabel: descriptor.label,\r\n\t\t\t\tlayout,\r\n\t\t\t\tentries: descriptor.group.getEntries(),\r\n\t\t\t}),\r\n\t\t\tlayout,\r\n\t\t}\r\n\t}\r\n}\r\n","export const PipelineLayout = (\r\n\tdevice: GPUDevice,\r\n\tdescriptor: GPUPipelineLayoutDescriptor | GPUBindGroupLayout[]\r\n): GPUPipelineLayout => {\r\n\tif (Array.isArray(descriptor)) {\r\n\t\treturn device.createPipelineLayout({\r\n\t\t\tbindGroupLayouts: descriptor,\r\n\t\t})\r\n\t} else return device.createPipelineLayout(descriptor)\r\n}\r\n\r\nexport const ComputePipeline = (\r\n\tdevice: GPUDevice,\r\n\tdescriptor: GPUComputePipelineDescriptor\r\n) => {\r\n\treturn device.createComputePipeline(descriptor)\r\n}\r\n\r\nexport const RenderPipeline = (\r\n\tdevice: GPUDevice,\r\n\tdescriptor: GPURenderPipelineDescriptor\r\n) => {\r\n\treturn device.createRenderPipeline(descriptor)\r\n}\r\n\r\nexport const Pipeline = {\r\n\tLayout: PipelineLayout,\r\n\tCompute: ComputePipeline,\r\n\tRender: RenderPipeline,\r\n}\r\n","export interface ComputePassMethods {\r\n\tdispatchWorkgroups: (\r\n\t\tworkgroupCountX: number,\r\n\t\tworkgroupCountY?: number | undefined,\r\n\t\tworkgroupCountZ?: number | undefined\r\n\t) => ComputePassMethods\r\n\r\n\tdispatchWorkgroupsIndirect: (\r\n\t\tindirectBuffer: GPUBuffer,\r\n\t\tindirectOffset: number\r\n\t) => ComputePassMethods\r\n\r\n\tend: () => void\r\n\r\n\tinsertDebugMarker: (markerLabel: string) => ComputePassMethods\r\n\r\n\tpopDebugGroup: () => ComputePassMethods\r\n\r\n\tpushDebugGroup: (groupLabel: string) => ComputePassMethods\r\n\r\n\tsetBindGroup: (\r\n\t\tindex: number,\r\n\t\tbindGroup: GPUBindGroup | null,\r\n\t\tdynamicOffsets?: Iterable<number> | undefined\r\n\t) => ComputePassMethods\r\n\r\n\tsetPipeline: (pipeline: GPUComputePipeline) => ComputePassMethods\r\n}\r\n\r\nexport const beginComputePass = (\r\n\tcommandEncoder: GPUCommandEncoder,\r\n\tdescriptor?: GPUComputePassDescriptor\r\n): ComputePassMethods => {\r\n\tconst computePass = commandEncoder.beginComputePass(descriptor)\r\n\r\n\tconst dispatchWorkgroups = (\r\n\t\tworkgroupCountX: number,\r\n\t\tworkgroupCountY?: number | undefined,\r\n\t\tworkgroupCountZ?: number | undefined\r\n\t) => {\r\n\t\tcomputePass.dispatchWorkgroups(\r\n\t\t\tworkgroupCountX,\r\n\t\t\tworkgroupCountY,\r\n\t\t\tworkgroupCountZ\r\n\t\t)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst dispatchWorkgroupsIndirect = (\r\n\t\tindirectBuffer: GPUBuffer,\r\n\t\tindirectOffset: number\r\n\t) => {\r\n\t\tcomputePass.dispatchWorkgroupsIndirect(indirectBuffer, indirectOffset)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst end = () => {\r\n\t\tcomputePass.end()\r\n\t}\r\n\r\n\tconst insertDebugMarker = (markerLabel: string) => {\r\n\t\tcomputePass.insertDebugMarker(markerLabel)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst popDebugGroup = () => {\r\n\t\tcomputePass.popDebugGroup()\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst pushDebugGroup = (groupLabel: string) => {\r\n\t\tcomputePass.pushDebugGroup(groupLabel)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst setBindGroup = (\r\n\t\tindex: number,\r\n\t\tbindGroup: GPUBindGroup | null,\r\n\t\tdynamicOffsets?: Iterable<number> | undefined\r\n\t) => {\r\n\t\tcomputePass.setBindGroup(index, bindGroup, dynamicOffsets)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst setPipeline = (pipeline: GPUComputePipeline) => {\r\n\t\tcomputePass.setPipeline(pipeline)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst methods: ComputePassMethods = {\r\n\t\tdispatchWorkgroups,\r\n\t\tdispatchWorkgroupsIndirect,\r\n\t\tend,\r\n\t\tinsertDebugMarker,\r\n\t\tpopDebugGroup,\r\n\t\tpushDebugGroup,\r\n\t\tsetBindGroup,\r\n\t\tsetPipeline,\r\n\t}\r\n\r\n\treturn methods\r\n}\r\n\r\nexport interface RenderPassMethods {\r\n\tbeginOcclusionQuery: (queryIndex: number) => RenderPassMethods\r\n\r\n\tdraw: (\r\n\t\tvertexCount: number,\r\n\t\tinstanceCount?: number | undefined,\r\n\t\tfirstVertex?: number | undefined,\r\n\t\tfirstInstance?: number | undefined\r\n\t) => RenderPassMethods\r\n\r\n\tdrawIndexed: (\r\n\t\tindexCount: number,\r\n\t\tinstanceCount?: number | undefined,\r\n\t\tfirstIndex?: number | undefined,\r\n\t\tbaseVertex?: number | undefined,\r\n\t\tfirstInstance?: number | undefined\r\n\t) => RenderPassMethods\r\n\r\n\tdrawIndexedIndirect: (\r\n\t\tindirectBuffer: GPUBuffer,\r\n\t\tindirectOffset: number\r\n\t) => RenderPassMethods\r\n\r\n\tdrawIndirect: (\r\n\t\tindirectBuffer: GPUBuffer,\r\n\t\tindirectOffset: number\r\n\t) => RenderPassMethods\r\n\r\n\tend: () => void\r\n\r\n\tendOcclusionQuery: () => RenderPassMethods\r\n\r\n\texecuteBundles: (bundles: Iterable<GPURenderBundle>) => RenderPassMethods\r\n\r\n\tinsertDebugMarker: (markerLabel: string) => RenderPassMethods\r\n\r\n\tpopDebugGroup: () => RenderPassMethods\r\n\r\n\tpushDebugGroup: (groupLabel: string) => RenderPassMethods\r\n\r\n\tsetBindGroup: (\r\n\t\tindex: number,\r\n\t\tbindGroup: GPUBindGroup | null,\r\n\t\tdynamicOffsets?: Iterable<number> | undefined\r\n\t) => RenderPassMethods\r\n\r\n\tsetBlendConstant: (color: GPUColor) => RenderPassMethods\r\n\r\n\tsetIndexBuffer: (\r\n\t\tbuffer: GPUBuffer,\r\n\t\tindexFormat: GPUIndexFormat,\r\n\t\toffset?: number | undefined,\r\n\t\tsize?: number | undefined\r\n\t) => RenderPassMethods\r\n\r\n\tsetPipeline: (pipeline: GPURenderPipeline) => RenderPassMethods\r\n\r\n\tsetScissorRect: (\r\n\t\tx: number,\r\n\t\ty: number,\r\n\t\twidth: number,\r\n\t\theight: number\r\n\t) => RenderPassMethods\r\n\r\n\tsetStencilReference: (reference: number) => RenderPassMethods\r\n\r\n\tsetVertexBuffer: (\r\n\t\tslot: number,\r\n\t\tbuffer: GPUBuffer | null,\r\n\t\toffset?: number | undefined,\r\n\t\tsize?: number | undefined\r\n\t) => RenderPassMethods\r\n\r\n\tsetViewport: (\r\n\t\tx: number,\r\n\t\ty: number,\r\n\t\twidth: number,\r\n\t\theight: number,\r\n\t\tminDepth: number,\r\n\t\tmaxDepth: number\r\n\t) => RenderPassMethods\r\n}\r\n\r\nexport const beginRenderPass = (\r\n\tcommandEncoder: GPUCommandEncoder,\r\n\tdescriptor: GPURenderPassDescriptor\r\n): RenderPassMethods => {\r\n\tconst renderPass = commandEncoder.beginRenderPass(descriptor)\r\n\r\n\tconst beginOcclusionQuery = (queryIndex: number) => {\r\n\t\trenderPass.beginOcclusionQuery(queryIndex)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst draw = (\r\n\t\tvertexCount: number,\r\n\t\tinstanceCount?: number | undefined,\r\n\t\tfirstVertex?: number | undefined,\r\n\t\tfirstInstance?: number | undefined\r\n\t) => {\r\n\t\trenderPass.draw(vertexCount, instanceCount, firstVertex, firstInstance)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst drawIndexed = (\r\n\t\tindexCount: number,\r\n\t\tinstanceCount?: number | undefined,\r\n\t\tfirstIndex?: number | undefined,\r\n\t\tbaseVertex?: number | undefined,\r\n\t\tfirstInstance?: number | undefined\r\n\t) => {\r\n\t\trenderPass.drawIndexed(\r\n\t\t\tindexCount,\r\n\t\t\tinstanceCount,\r\n\t\t\tfirstIndex,\r\n\t\t\tbaseVertex,\r\n\t\t\tfirstInstance\r\n\t\t)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst drawIndexedIndirect = (\r\n\t\tindirectBuffer: GPUBuffer,\r\n\t\tindirectOffset: number\r\n\t) => {\r\n\t\trenderPass.drawIndexedIndirect(indirectBuffer, indirectOffset)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst drawIndirect = (indirectBuffer: GPUBuffer, indirectOffset: number) => {\r\n\t\trenderPass.drawIndirect(indirectBuffer, indirectOffset)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst end = () => {\r\n\t\trenderPass.end()\r\n\t}\r\n\r\n\tconst endOcclusionQuery = () => {\r\n\t\trenderPass.endOcclusionQuery()\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst executeBundles = (bundles: Iterable<GPURenderBundle>) => {\r\n\t\trenderPass.executeBundles(bundles)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst insertDebugMarker = (markerLabel: string) => {\r\n\t\trenderPass.insertDebugMarker(markerLabel)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst popDebugGroup = () => {\r\n\t\trenderPass.popDebugGroup()\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst pushDebugGroup = (groupLabel: string) => {\r\n\t\trenderPass.pushDebugGroup(groupLabel)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst setBindGroup = (\r\n\t\tindex: number,\r\n\t\tbindGroup: GPUBindGroup | null,\r\n\t\tdynamicOffsets?: Iterable<number> | undefined\r\n\t) => {\r\n\t\trenderPass.setBindGroup(index, bindGroup, dynamicOffsets)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst setBlendConstant = (color: GPUColor) => {\r\n\t\trenderPass.setBlendConstant(color)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst setIndexBuffer = (\r\n\t\tbuffer: GPUBuffer,\r\n\t\tindexFormat: GPUIndexFormat,\r\n\t\toffset?: number | undefined,\r\n\t\tsize?: number | undefined\r\n\t) => {\r\n\t\trenderPass.setIndexBuffer(buffer, indexFormat, offset, size)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst setPipeline = (pipeline: GPURenderPipeline) => {\r\n\t\trenderPass.setPipeline(pipeline)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst setScissorRect = (\r\n\t\tx: number,\r\n\t\ty: number,\r\n\t\twidth: number,\r\n\t\theight: number\r\n\t) => {\r\n\t\trenderPass.setScissorRect(x, y, width, height)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst setStencilReference = (reference: number) => {\r\n\t\trenderPass.setStencilReference(reference)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst setVertexBuffer = (\r\n\t\tslot: number,\r\n\t\tbuffer: GPUBuffer | null,\r\n\t\toffset?: number | undefined,\r\n\t\tsize?: number | undefined\r\n\t) => {\r\n\t\trenderPass.setVertexBuffer(slot, buffer, offset, size)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst setViewport = (\r\n\t\tx: number,\r\n\t\ty: number,\r\n\t\twidth: number,\r\n\t\theight: number,\r\n\t\tminDepth: number,\r\n\t\tmaxDepth: number\r\n\t) => {\r\n\t\trenderPass.setViewport(x, y, width, height, minDepth, maxDepth)\r\n\t\treturn methods\r\n\t}\r\n\r\n\tconst methods: RenderPassMethods = {\r\n\t\tbeginOcclusionQuery,\r\n\t\tdraw,\r\n\t\tdrawIndexed,\r\n\t\tdrawIndexedIndirect,\r\n\t\tdrawIndirect,\r\n\t\tend,\r\n\t\tendOcclusionQuery,\r\n\t\texecuteBundles,\r\n\t\tinsertDebugMarker,\r\n\t\tpopDebugGroup,\r\n\t\tpushDebugGroup,\r\n\t\tsetBindGroup,\r\n\t\tsetBlendConstant,\r\n\t\tsetIndexBuffer,\r\n\t\tsetPipeline,\r\n\t\tsetScissorRect,\r\n\t\tsetStencilReference,\r\n\t\tsetVertexBuffer,\r\n\t\tsetViewport,\r\n\t}\r\n\r\n\treturn methods\r\n}\r\n\r\nexport const createRenderPassDescriptor = (\r\n\tdescriptor: GPURenderPassDescriptor\r\n): GPURenderPassDescriptor => {\r\n\treturn descriptor\r\n}\r\n\r\nexport const Pass = {\r\n\tCompute: beginComputePass,\r\n\tRender: beginRenderPass,\r\n\tRenderPassDescriptor: createRenderPassDescriptor,\r\n}\r\n"],"names":[],"version":3,"file":"Orton.js.map"}