const e={i8:Int8Array,i16:Int16Array,i32:Int32Array,u8:Uint8Array,u16:Uint16Array,u32:Uint32Array,f32:Float32Array},t=(t,r="f32")=>{if(Array.isArray(t))return new e[r](t.flat(1/0));if("number"==typeof t)return new e[r](t);throw new Error("Unsupported data type")},r=(e,t)=>{const r=document.createElement("div");r.style.cssText="\n\t\t\tposition: fixed;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\twidth: 100%;\n\t\t\theight: 100%;\n\t\t\tbackground: rgba(0, 0, 0, 0.9);\n\t\t\tdisplay: none;\n\t\t\tdisplay: flex;\n\t\t\tjustify-content: center;\n\t\t\talign-items: center;\n\t\t\tz-index: 999;\n\t";const n=document.createElement("div");function i(){r.style.display="none"}return n.style.cssText="\n\t\t\tcolor: red;\n\t\t\tfont-size: 24px;\n\t\t\ttext-align: center;\n\t\t\tfont-family: 'Consolas', monospace;\n\t",n.innerHTML=`<h2>${e}</h2><p>${t}</p>`,r.appendChild(n),document.body.appendChild(r),r.addEventListener("click",i),{show:function(){r.style.display="flex"},hide:i}},n={Vertex:(e,t)=>({module:e.createShaderModule({label:t.label,code:t.code}),entryPoint:t.entryPoint||"main",buffers:t.buffers}),Fragment:(e,t)=>({module:e.createShaderModule({label:t.label,code:t.code}),entryPoint:t.entryPoint||"main",targets:t.targets}),Compute:(e,t)=>"string"==typeof t?{module:e.createShaderModule({code:t}),entryPoint:"main"}:{module:e.createShaderModule({label:t.label,code:t.code}),entryPoint:t.entryPoint||"main"}},i=(e,t)=>e.createBuffer({label:t.label,size:t.size,usage:t.usage.reduce(((e,t)=>e|GPUBufferUsage[t]),0)}),o=({format:e,offset:t,shaderLocation:r})=>({format:e,offset:t,shaderLocation:r}),a=({arrayStride:e,stepMode:t="vertex",attributes:r})=>({arrayStride:e,stepMode:t,attributes:r});const s=e=>({...e,bindGroupLayoutEntry:t=>({binding:t,visibility:e.visibility.reduce(((e,t)=>e|GPUShaderStage[t]),0),buffer:{type:e.type},externalTexture:e.externalTexture,sampler:e.sampler,storageTexture:e.storageTexture,texture:e.texture}),bindGroupEntry:t=>({binding:t,resource:{buffer:e.buffer}})});const u=e=>({getLayoutEntries:()=>e.map(((e,t)=>e.bindGroupLayoutEntry(t))),getEntries:()=>e.map(((e,t)=>e.bindGroupEntry(t)))});const d=(e,t)=>{if(Array.isArray(t)&&"bindGroupLayoutEntry"in t[0]){const r=u(t),n=e.createBindGroupLayout({entries:r.getLayoutEntries()});return{bindGroup:e.createBindGroup({layout:n,entries:r.getEntries()}),layout:n}}if(function(e){return"getLayoutEntries"in e}(t)){const r=e.createBindGroupLayout({entries:t.getLayoutEntries()});return{bindGroup:e.createBindGroup({layout:r,entries:t.getEntries()}),layout:r}}if(function(e){return"group"in e}(t)){const r=e.createBindGroupLayout({entries:t.group.getLayoutEntries()});return{bindGroup:e.createBindGroup({label:t.label,layout:r,entries:t.group.getEntries()}),layout:r}}},p=(e,t)=>Array.isArray(t)?e.createPipelineLayout({bindGroupLayouts:t}):e.createPipelineLayout(t),c=(e,t)=>e.createComputePipeline(t),l=(e,t)=>e.createRenderPipeline(t),y={Layout:p,Compute:c,Render:l},f=(e,t)=>{const r=e.beginComputePass(t),n={dispatchWorkgroups:(e,t,i)=>(r.dispatchWorkgroups(e,t,i),n),dispatchWorkgroupsIndirect:(e,t)=>(r.dispatchWorkgroupsIndirect(e,t),n),end:()=>{r.end()},insertDebugMarker:e=>(r.insertDebugMarker(e),n),popDebugGroup:()=>(r.popDebugGroup(),n),pushDebugGroup:e=>(r.pushDebugGroup(e),n),setBindGroup:(e,t,i)=>(r.setBindGroup(e,t,i),n),setPipeline:e=>(r.setPipeline(e),n)};return n},g=(e,t)=>{const r=e.beginRenderPass(t),n={beginOcclusionQuery:e=>(r.beginOcclusionQuery(e),n),draw:(e,t,i,o)=>(r.draw(e,t,i,o),n),drawIndexed:(e,t,i,o,a)=>(r.drawIndexed(e,t,i,o,a),n),drawIndexedIndirect:(e,t)=>(r.drawIndexedIndirect(e,t),n),drawIndirect:(e,t)=>(r.drawIndirect(e,t),n),end:()=>{r.end()},endOcclusionQuery:()=>(r.endOcclusionQuery(),n),executeBundles:e=>(r.executeBundles(e),n),insertDebugMarker:e=>(r.insertDebugMarker(e),n),popDebugGroup:()=>(r.popDebugGroup(),n),pushDebugGroup:e=>(r.pushDebugGroup(e),n),setBindGroup:(e,t,i)=>(r.setBindGroup(e,t,i),n),setBlendConstant:e=>(r.setBlendConstant(e),n),setIndexBuffer:(e,t,i,o)=>(r.setIndexBuffer(e,t,i,o),n),setPipeline:e=>(r.setPipeline(e),n),setScissorRect:(e,t,i,o)=>(r.setScissorRect(e,t,i,o),n),setStencilReference:e=>(r.setStencilReference(e),n),setVertexBuffer:(e,t,i,o)=>(r.setVertexBuffer(e,t,i,o),n),setViewport:(e,t,i,o,a,s)=>(r.setViewport(e,t,i,o,a,s),n)};return n},b=e=>e,P={Compute:f,Render:g,RenderPassDescriptor:b},m=async(e,t)=>{const m=navigator.gpu;if(!m){const e="WebGPU is not supported in this browser";return console.error(e),void r("Error",e)}const x=await m.requestAdapter();if(!x){const e="couldn't request WebGPU adapter";return console.error(e),void r("Error",e)}const G=await(x?.requestDevice(t));G.lost.then((()=>{console.error("WebGPU device was lost...")}));const h=e.getContext("webgpu"),B=m.getPreferredCanvasFormat(),w=G.queue;return{gpu:m,adapter:x,device:G,context:h,preferredFormat:B,queue:w,getCurrentTexture:()=>h?.getCurrentTexture(),createView:()=>h?.getCurrentTexture().createView(),CommandEncoder:e=>e.createCommandEncoder(),Shader:n,Buffer:i,createVertexAttribute:o,createVertexBufferLayout:a,Binding:s,Group:u,BindGroup:d,PipelineLayout:p,ComputePipeline:c,RenderPipeline:l,Pipeline:y,beginComputePass:f,beginRenderPass:g,createRenderPassDescriptor:b,Pass:P}},x={init:m};export{m as init,x as Orton,t as Data,n as Shader,i as Buffer,o as createVertexAttribute,a as createVertexBufferLayout,s as Binding,u as Group,d as BindGroup,p as PipelineLayout,c as ComputePipeline,l as RenderPipeline,y as Pipeline,f as beginComputePass,g as beginRenderPass,b as createRenderPassDescriptor,P as Pass};